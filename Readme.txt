4η Εργασία Λειτουργικών Συστημάτων (τμήμα Δελή)

Valentin Ivanov 
ΑΜ: 1115 2014 00049

Μανούσος Τοράκης
ΑΜ: 1115 2014 00201

Η εργασία έχει υλοποιηθεί ολόκληρη εκτός απο το προερετικό μέρος της διαγραφής αρχείων/καταλόγων απο το .di αρχείο.

Το αρχείο μας αποτελείται απο 3 βασικά μέρη.

Αρχικά έχουμε ένα Header που περιέχει διάφορες πληροφορίες για το .di αρχείο όπως:
	1) Μέγεθος
	2) Αριθμός αρχείων/καταλόγων (inodes) στο αρχείο
	3) Την αρχή των έξτρα μέτα-πληροφοριών για την ιεραρχία των καταλόγων το είδος των αρχείων κτλ.

Το 2ο μέρος του αρχείο είναι όλα τα αρχεία το ένα μετά το άλλο σειριακά.

Το 3ο και πιο σημαντικό μέρος είναι οι μέτα-πληροφορίες για τα συμπιεσμένα αρχεία και την ιεαρχική δομή τους.

Για την αναπαράστη αυτών έχουμε σχεδιάσει μια δομή παρόμοια με τα i-nodes των unix συστημάτων και όμοια με το παράδειγμα της εκφώνησης.
Πρακτικά σε κάθε BLOCK του αρχείου έχουμε μια λίστα απο dinodes της παρακάτω μορφής:

struct dinode
{
	struct stat node_info;
	off_t compression_size;
	int pointer;/*block offset of dir info for dirs,block of file for files*/
};

struct dinodelist
{
	int count;
	int next;
	dinode * dinodes;
};

Σε κάθε μπλοκ γράφεται ένα dinodelist.
Ο pointer στην δομή dinode, ανάλογα με το αν το αντικείμενο είναι αρχείο-file ή κατάλογος-directory δείχνει σε:
	1) Αν αρχείο τότε δείχνει στο μπλοκ στο οποίο γράφεταί το ίδιο το αρχείο.
	2) Αν κατάλογος τότε το pointer δείχνει σε πόσα μπλός παρακάτω είναι η πληροφορία dirInfo για τον κατάλογο.

struct dirEntry
{
	char name[30];
	int dinode_num;
};


struct dirInfo
{
	int count;	
	int next;
	dirEntry * entries;

	/*following is not to be saved at file*/
	int dirIndex;
	int block_num;
};

Ένα dirInfo είναι η πληροφορία για το τι περιέχει ένας κατάλογος.
Αυτή αποτελείται απο dirEntries που είναι μια δομή η οποία περιέχει το όνομα και ενας δείκτης(αριθμός) που δείχνει σε ποια θέση (αριθμιτική θέση) βρίσκεται το dinode το οποίο περιγράφει αυτό το όνομα.

Οι μεταβλητές: dinodelist.count, dinodelist.next, dirInfo.count dirInfo.next είναι απλά βοηθητικές ώστε να μπορούμε να κεινούμαστε μέσα στο αρχείο και να μην χάνουμε την σειρά με την οποία αυτά έχουν αποθηκευτεί.

Πρακτικά χωρίς αυτά έχουμε:
	
	1)Εναν πίνακα απο dinodes τ/ω:
		Το 1ο στοιχείο να είναι το root του αρχείου.
		Κάθε επόμενο είναι dinode που περιγράφει το αμέσως επόμενο ων (file or directory) με βάση την πρώτα κατά βάθος αναζήτηση στην δενδική ιεραρχεία των φακέλων που μας έχουν δωθεί.
	2)Για κάθε DIRECTORY έχουμε έναν κατάλογο απο <ονόμα,αριθμος> όπου το όνομα είναι τα ονόματα των αρχείων/καταλόγων που βρίσκονται στο DIRECTORY και την θέση στον πίνακα με τα dinodes όπου βρίσκεται το dinode αυτού του ονόματος.

Έτσι έχουμε αναδρομικές συναρτήσεις οι οποίες κινούνται σε αυτές τις δοκμές και μπορούν να συμπιέσουν, αποσυμπιέσουν και να γνωρίζουν την δομή των αρχείων/καταλόγων που υπάρχουν στο αρχείο .di.



Έχουμε υλοποιήσει τα ερωτήματα 
	-c Δημιουργεία .di αρχείου με βάση την λιστα που μας δίνεται στην γραμμή εντολής
	-a Παράθεση(append) του .di αρχείου με βάση την λιστα που μας δίνεται στην γραμμή εντολής
	-p Εκτύπωση ιεραρχείας του .di αρχείου
	-m Εκτύπωση μέτα-πληροφοριώνν για τα αρχεία/κατάλογοι που εμπέριέχει ενα .di αρχείο
	-q Επερώτηση για τον αν υπάρχουν ορισμένα αρχεία/κατάλογοι στο .di αρχείο
	-j Προερετική συμπίεση gzip των αρχείων πριν αυτά γραφούν στο αρχείο.
	-x Εξαγωγή καταλόγων/αρχείων απο το .di αρχείο

Σε κάθε dinode αποθηκεύω το stat του αρχείου/καταλόγου.

struct stat {
    dev_t     st_dev;     /* ID of device containing file */
    ino_t     st_ino;     /* inode number */
    mode_t    st_mode;    /* protection */
    nlink_t   st_nlink;   /* number of hard links */
    uid_t     st_uid;     /* user ID of owner */
    gid_t     st_gid;     /* group ID of owner */
    dev_t     st_rdev;    /* device ID (if special file) */
    off_t     st_size;    /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
    time_t    st_atime;   /* time of last access */
    time_t    st_mtime;   /* time of last modification */
    time_t    st_ctime;   /* time of last status change */
};

Αυτό εμπεριέχει χρήσιμες πληροφόρίες.
Χάρη σε αυτό στην εξαγωγή μπορώ να δράσω ανάλογα με το είδος που εξετάζουμε.
Έτσι αν directory πρέπει να δημιουργήσω έναν νεο κατάλογο με το όνομα του(μεσου του dirEntry) και να κάνω cd σε αυτό τον κατάλογο και να συνίσω την αναδρομική κλήση για αυτόν τον νεο κατάλογο που μόλις δημιούργησα.
Αν αρχείο τότε θα το κάνω extract σε στο τρέχουν κατάλογο(κάτω απο ορισμλενες προϋποθέσεις αναλογά με το αν είναι hard link που εξηγώ παρακάτω).
Επιπλέον αν είναι soft-symbolic link τότε μπορώ απλά να φτίαξω ενα νεο symbolic link στο όνομα στο οποίο δείχνει, μέσω της συνάρτησης symlink().


Για τα links εξακολουθώ την εξής στρατιγική:
	Κάθε φορά που πάω να βάλω ενα αρχείο στο .di ελέγχω μήπως το inode του υπάρχει είδη μέσα στο αρχείο. Αν ναί τοτέ απλά βάζω το dirEntry του στον κατάλογο όπου βρίσκεται το hard link αυτό. 
	Έτσι δεν ξαναγράφω το αρχείο με σто .di.

	Στην εξαγωγή των αρχείων απο ενα .di αρχείο χρησιμοποιώ μια βοηθητική δομή την node.

typedef struct node
{
	struct stat node_info;
	off_t compression_size;
	int block;
	int offset;

	char extracted;		Αρχικά 0. Αν ενα inode με πολλά >1 hard links έχει είδη εξαχθεί απο το αρχείο
	char *pathname;		Αν extracted==1 τότε το pathname είναι το όνομα με το οποίο εξάχθει το παρόν inode.
}node ;

Αυτή πρακτικά είναι ο πίνακάς των όλων των dinodes με κάποιες παραπάνω πληροφορίες που χριάζονται στην εξαγωγή.
Έτσι την πρώτη φορά που θα δω ένα inode file τότε θα τα εξαγάγω με το όνομα που το περιγράφει στο dirEntry και θα κανω το 
		
		extracted = 1;
		pathname = dirEntry.name; με το οποίο εξαγάγει

Κάθε επόμενη φορά που θα βλέπω ένα όνομα το οποίο θα δείχνει σε αυτό το inode δεν θα ξαναεξαγάγω το αρχείο αλλα θα δημιουργήσω απλά ενα νεο hard link το όποιο να δείχνει στο αρχείο που έχει εξαχθεί είδη.
Αυτό το κάνω μέσω της συνάρτησης link() η οποία πρέπει να γνωρίζει το relative path του ονόματος απο τό πραγματικό αρχείο.
Για να το κάνω αυτό έχουμε μια συνάρτηση η οποία βρίσκει το relative path του όνοματος του hard link απο το pathname το οποίο αποθηκεύσαμε στην εξαγωγή.

Οι περισσότερες συναρτήσεις που χρησιμοποιώ βασίζονται σε με αναδρομή για κάθε κατάλογο η οποία κάνει τα εξής πράγματα:
	1) Παίρνει απο το αρχείο το dirInfo, δηλαδή τα περιεχόμενα του τρέχον καταλόγου.
	2) Τα εξετάζει ένα-ένα και ανάλογα με το αν είναι regular file, directory ή symbolic link δρά με τον ανάλογο τρόπο
		α)Στην περίπτωση που το εξεταζόμενο στοιχείο είναι και αυτό κατάλογος(δηλαδή υποκατάλογος του τρέχοντος καταλόγου), τότε καλεί αναδρομικά τον εαυτό της για αυτό το στοιχείο-κατάλογο.
		β) Αν αρχείο ή sof link τότε θα κάνει εξαγωγή ή εκτύπωση με τον τρόπο που εξήγησα παραπάνω.

